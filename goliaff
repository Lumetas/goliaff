#!/usr/bin/env python3

import os
import sys
import json
import subprocess
import shlex
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Union
from enum import Enum


class Operation(Enum):
    """Operation types for dry-run mode"""
    INSTALL = "Install"
    REMOVE = "Remove"
    ENABLE = "Enable"
    DISABLE = "Disable"
    START = "Start"
    STOP = "Stop"
    CREATE = "Create"
    DELETE = "Delete"
    MODIFY = "Modify"
    SET = "Set"
    CLONE = "Clone"


@dataclass
class DryRunOperation:
    """Operation for dry-run mode"""
    op: Operation
    description: str
    command: Optional[str] = None


class SystemConfigurator:
    """Main system configuration class"""
    
    def __init__(self, config_path: str = 'config.json', dry_run: bool = False):
        self.dry_run = dry_run
        self.dry_run_ops: List[DryRunOperation] = []
        self.config_path = config_path
        self.config: Dict[str, Any] = {}
        
    def log_change(self, message: str):
        """Logs only changes"""
        if not self.dry_run:
            print(f"✓ {message}")
        else:
            print(f"[DRY RUN] {message}")
    
    def log_info(self, message: str):
        """Logs information"""
        if not self.dry_run:
            print(f"  {message}")
    
    def log_warning(self, message: str):
        """Logs warnings"""
        print(f"⚠ {message}")
    
    def log_error(self, message: str):
        """Logs errors"""
        print(f"✗ {message}")
    
    def add_dry_run_op(self, op: Operation, description: str, command: Optional[str] = None):
        """Adds operation to dry-run operations list"""
        if self.dry_run:
            self.dry_run_ops.append(DryRunOperation(op, description, command))
    
    def run_command(self, cmd: str) -> tuple[int, str, str]:
        """Executes shell command"""
        if self.dry_run:
            return 0, "", ""
        
        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                encoding='utf-8'
            )
            return result.returncode, result.stdout.strip(), result.stderr.strip()
        except Exception as e:
            return -1, "", str(e)
    
    def load_config_recursive(self, config: Dict[str, Any], base_path: str = '') -> Dict[str, Any]:
        """Recursively loads configuration with @include processing"""
        result = {}
        
        for key, value in config.items():
            if isinstance(value, str) and value.startswith('@include:'):
                include_file = value[len('@include:'):]
                
                if base_path and not include_file.startswith('/'):
                    include_file = os.path.join(base_path, include_file)
                
                if not os.path.exists(include_file):
                    self.log_warning(f"Include file not found: {include_file}")
                    continue
                
                try:
                    with open(include_file, 'r', encoding='utf-8') as f:
                        included_config = json.load(f)
                except (json.JSONDecodeError, IOError) as e:
                    self.log_warning(f"Invalid JSON or unable to read file: {include_file} - {e}")
                    continue
                
                result[key] = self.load_config_recursive(
                    included_config, 
                    os.path.dirname(include_file)
                )
            elif isinstance(value, dict):
                result[key] = self.load_config_recursive(value, base_path)
            else:
                result[key] = value
        
        return result
    
    def load_config(self) -> bool:
        """Loads configuration"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                main_config = json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            self.log_error(f"Invalid JSON or unable to read {self.config_path}: {e}")
            self.log_info(f"Current directory: {os.getcwd()}")
            return False
        
        self.config = self.load_config_recursive(
            main_config, 
            os.path.dirname(self.config_path)
        )
        return True
    
    def get_current_distro_config(self) -> Optional[Dict[str, Any]]:
        """Returns current distribution configuration"""
        current_distro = self.config.get('currentDistro')
        if not current_distro:
            self.log_error("currentDistro not defined in config")
            return None
        
        distros = self.config.get('distros', {})
        distro_config = distros.get(current_distro)
        if not distro_config:
            self.log_error(f"Distribution configuration not found: {current_distro}")
            return None
        
        return distro_config
    
    # ========== Package Management ==========
    
    def check_package_installed(self, pkg_name: str, distro_config: Dict[str, Any]) -> bool:
        """Checks if package is installed"""
        pkgs_config = distro_config.get('pkgs', {})
        check_cmd = pkgs_config.get('check')
        
        if not check_cmd:
            return False
        
        check_cmd = check_cmd.replace('%pkg%', pkg_name)
        returncode, stdout, stderr = self.run_command(check_cmd)
        
        return returncode == 0 and stdout.strip() == "1"
    
    def manage_packages(self):
        """Manages packages based on declarative configuration"""
        if 'dependencies' not in self.config:
            self.log_info("Dependencies not defined in config")
            return
        
        distro_config = self.get_current_distro_config()
        if not distro_config:
            return
        
        current_distro = self.config.get('currentDistro')
        self.log_info(f"Managing packages for distribution: {current_distro}")
        
        dependencies = self.config.get('dependencies', {})
        for pkg_key, pkg_config in dependencies.items():
            if not isinstance(pkg_config, dict):
                continue
            
            pkg_distro_config = pkg_config.get(current_distro, pkg_config.get('default'))
            if not pkg_distro_config:
                self.log_warning(f"Configuration for {pkg_key} on {current_distro} not found")
                continue
            
            pkg_name = pkg_distro_config.get('name', pkg_key)
            should_be_installed = pkg_distro_config.get('installed', False)
            is_installed = self.check_package_installed(pkg_name, distro_config)
            
            if should_be_installed and not is_installed:
                self._install_package(pkg_name, distro_config)
            elif not should_be_installed and is_installed:
                self._remove_package(pkg_name, distro_config)
    
    def _install_package(self, pkg_name: str, distro_config: Dict[str, Any]):
        """Installs package"""
        pkgs_config = distro_config.get('pkgs', {})
        install_cmd = pkgs_config.get('install')
        
        if not install_cmd:
            self.log_error(f"Install command not defined for distribution")
            return
        
        install_cmd = install_cmd.replace('%pkg%', pkg_name)
        self.add_dry_run_op(Operation.INSTALL, f"Package: {pkg_name}", install_cmd)
        
        if self.dry_run:
            return
        
        self.log_change(f"Installing package: {pkg_name}")
        returncode, stdout, stderr = self.run_command(install_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to install {pkg_name}: {stderr}")
    
    def _remove_package(self, pkg_name: str, distro_config: Dict[str, Any]):
        """Removes package"""
        pkgs_config = distro_config.get('pkgs', {})
        remove_cmd = pkgs_config.get('remove')
        
        if not remove_cmd:
            self.log_error(f"Remove command not defined for distribution")
            return
        
        remove_cmd = remove_cmd.replace('%pkg%', pkg_name)
        self.add_dry_run_op(Operation.REMOVE, f"Package: {pkg_name}", remove_cmd)
        
        if self.dry_run:
            return
        
        self.log_change(f"Removing package: {pkg_name}")
        returncode, stdout, stderr = self.run_command(remove_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to remove {pkg_name}: {stderr}")
    
    # ========== Service Management ==========
    
    def check_service_status(self, service_name: str, service_type: str, 
                           distro_config: Dict[str, Any]) -> bool:
        """Checks service status"""
        services_config = distro_config.get('services', {})
        service_cmds = services_config.get('system')
        
        if service_type == 'user':
            service_cmds = services_config.get('user')
        
        if not service_cmds or 'enabled' not in service_cmds:
            return False
        
        check_cmd = service_cmds['enabled'].replace('%service%', service_name)
        returncode, stdout, stderr = self.run_command(check_cmd)
        
        return returncode == 0 and stdout.strip() == "1"
    
    def check_service_running(self, service_name: str, service_type: str,
                            distro_config: Dict[str, Any]) -> bool:
        """Checks if service is running"""
        services_config = distro_config.get('services', {})
        service_cmds = services_config.get('system')
        
        if service_type == 'user':
            service_cmds = services_config.get('user')
        
        if not service_cmds or 'started' not in service_cmds:
            return False
        
        check_cmd = service_cmds['started'].replace('%service%', service_name)
        returncode, stdout, stderr = self.run_command(check_cmd)
        
        return returncode == 0 and stdout.strip() == "1"
    
    def manage_services(self):
        """Manages services based on declarative configuration"""
        if 'services' not in self.config:
            self.log_info("Services not defined in config")
            return
        
        distro_config = self.get_current_distro_config()
        if not distro_config:
            return
        
        current_distro = self.config.get('currentDistro')
        self.log_info(f"Managing services for distribution: {current_distro}")
        
        services = self.config.get('services', {})
        for service_key, service_config in services.items():
            if not isinstance(service_config, dict):
                continue
            
            service_distro_config = service_config.get(current_distro)
            if not service_distro_config:
                continue
            
            service_name = service_distro_config.get('name')
            if not service_name:
                continue
            
            should_be_enabled = service_distro_config.get('enable', False)
            should_be_started = service_distro_config.get('start', False)
            is_user_service = service_distro_config.get('user', False)
            
            service_type = 'user' if is_user_service else 'system'
            
            is_enabled = self.check_service_status(
                service_name, service_type, distro_config
            )
            is_running = self.check_service_running(
                service_name, service_type, distro_config
            )
            
            # Manage enable/disable
            if should_be_enabled and not is_enabled:
                self._enable_service(service_name, service_type, distro_config)
            elif not should_be_enabled and is_enabled:
                self._disable_service(service_name, service_type, distro_config)
            
            # Manage start/stop
            if should_be_started and not is_running:
                self._start_service(service_name, service_type, distro_config)
            elif not should_be_started and is_running:
                self._stop_service(service_name, service_type, distro_config)
    
    def _enable_service(self, service_name: str, service_type: str,
                       distro_config: Dict[str, Any]):
        """Enables service"""
        services_config = distro_config.get('services', {})
        service_cmds = services_config.get('system')
        
        if service_type == 'user':
            service_cmds = services_config.get('user')
        
        if not service_cmds or 'enable' not in service_cmds:
            self.log_error(f"Enable command not defined for {service_type} services")
            return
        
        enable_cmd = service_cmds['enable'].replace('%service%', service_name)
        self.add_dry_run_op(
            Operation.ENABLE, 
            f"Service: {service_name} ({service_type})", 
            enable_cmd
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Enabling {service_type} service: {service_name}")
        returncode, stdout, stderr = self.run_command(enable_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to enable {service_name}: {stderr}")
    
    def _disable_service(self, service_name: str, service_type: str,
                        distro_config: Dict[str, Any]):
        """Disables service"""
        services_config = distro_config.get('services', {})
        service_cmds = services_config.get('system')
        
        if service_type == 'user':
            service_cmds = services_config.get('user')
        
        if not service_cmds or 'disable' not in service_cmds:
            self.log_error(f"Disable command not defined for {service_type} services")
            return
        
        disable_cmd = service_cmds['disable'].replace('%service%', service_name)
        self.add_dry_run_op(
            Operation.DISABLE,
            f"Service: {service_name} ({service_type})",
            disable_cmd
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Disabling {service_type} service: {service_name}")
        returncode, stdout, stderr = self.run_command(disable_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to disable {service_name}: {stderr}")
    
    def _start_service(self, service_name: str, service_type: str,
                      distro_config: Dict[str, Any]):
        """Starts service"""
        services_config = distro_config.get('services', {})
        service_cmds = services_config.get('system')
        
        if service_type == 'user':
            service_cmds = services_config.get('user')
        
        if not service_cmds or 'start' not in service_cmds:
            self.log_error(f"Start command not defined for {service_type} services")
            return
        
        start_cmd = service_cmds['start'].replace('%service%', service_name)
        self.add_dry_run_op(
            Operation.START,
            f"Service: {service_name} ({service_type})",
            start_cmd
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Starting {service_type} service: {service_name}")
        returncode, stdout, stderr = self.run_command(start_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to start {service_name}: {stderr}")
    
    def _stop_service(self, service_name: str, service_type: str,
                     distro_config: Dict[str, Any]):
        """Stops service"""
        services_config = distro_config.get('services', {})
        service_cmds = services_config.get('system')
        
        if service_type == 'user':
            service_cmds = services_config.get('user')
        
        if not service_cmds or 'stop' not in service_cmds:
            self.log_error(f"Stop command not defined for {service_type} services")
            return
        
        stop_cmd = service_cmds['stop'].replace('%service%', service_name)
        self.add_dry_run_op(
            Operation.STOP,
            f"Service: {service_name} ({service_type})",
            stop_cmd
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Stopping {service_type} service: {service_name}")
        returncode, stdout, stderr = self.run_command(stop_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to stop {service_name}: {stderr}")
    
    # ========== Extra Packages Management ==========
    
    def expand_path(self, path: str) -> str:
        """Expands paths with ~/ to home directory"""
        if path.startswith('~/'):
            return os.path.join(os.path.expanduser('~'), path[2:])
        return path
    
    def manage_extra_packages(self):
        """Manages extra packages"""
        if 'extraPkgs' not in self.config:
            return
        
        self.log_info("Managing extra packages")
        extra_pkgs = self.config.get('extraPkgs', {})
        
        for path, url in extra_pkgs.items():
            expanded_path = self.expand_path(path)
            
            if not os.path.exists(expanded_path):
                self._clone_extra_package(url, expanded_path)
    
    def _clone_extra_package(self, url: str, path: str):
        """Clones extra package"""
        dir_path = os.path.dirname(path)
        if dir_path and not os.path.exists(dir_path):
            try:
                os.makedirs(dir_path, 0o755, exist_ok=True)
            except OSError as e:
                self.log_error(f"Failed to create directory {dir_path}: {e}")
                return
        
        clone_cmd = f"git clone {shlex.quote(url)} {shlex.quote(path)}"
        self.add_dry_run_op(Operation.CLONE, f"Repository: {url} → {path}", clone_cmd)
        
        if self.dry_run:
            return
        
        self.log_change(f"Cloning: {url} to {path}")
        returncode, stdout, stderr = self.run_command(clone_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to clone {url}: {stderr}")
    
    def uninstall_extra_packages(self):
        """Removes extra packages"""
        if 'extraPkgs' not in self.config:
            return
        
        self.log_info("Removing extra packages")
        extra_pkgs = self.config.get('extraPkgs', {})
        
        for path, url in extra_pkgs.items():
            expanded_path = self.expand_path(path)
            
            if os.path.exists(expanded_path):
                self.add_dry_run_op(
                    Operation.REMOVE,
                    f"Directory: {expanded_path}",
                    f"rm -rf {shlex.quote(expanded_path)}"
                )
                
                if self.dry_run:
                    continue
                
                self.log_change(f"Removing: {expanded_path}")
                try:
                    import shutil
                    shutil.rmtree(expanded_path)
                except OSError as e:
                    self.log_error(f"Failed to remove {expanded_path}: {e}")
    
    # ========== Stow Management ==========
    
    def manage_stow(self):
        """Manages configurations via stow"""
        self.log_info("Managing Stow configurations")
        
        if 'WM' in self.config:
            self._manage_stow_elements(self.config['WM'], 'WM')
        
        if 'PKGS' in self.config:
            self._manage_stow_elements(self.config['PKGS'], 'PKGS')
    
    def _manage_stow_elements(self, elements: Dict[str, Any], category: str):
        """Manages stow elements"""
        for element, element_data in elements.items():
            if isinstance(element_data, dict) and element_data.get('active', False):
                self._enable_stow_element(element, element_data)
            else:
                self._disable_stow_element(element)
    
    def _enable_stow_element(self, element: str, element_data: Dict[str, Any]):
        """Enables stow element"""
        in_dir = ""
        if element_data.get('path'):
            in_dir = f"-t {shlex.quote(element_data['path'])}"
        
        stow_cmd = f"stow {in_dir} {shlex.quote(element)}"
        self.add_dry_run_op(
            Operation.ENABLE,
            f"Stow element: {element}",
            stow_cmd
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Enabling Stow element: {element}")
        returncode, stdout, stderr = self.run_command(stow_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to enable {element}: {stderr}")
            return
        
        # Run build command if exists
        if 'build' in element_data:
            build_cmd = element_data['build']
            self.add_dry_run_op(
                Operation.INSTALL,
                f"Build: {element}",
                build_cmd
            )
            
            if self.dry_run:
                return
            
            self.log_info(f"Building {element}: {build_cmd}")
            returncode, stdout, stderr = self.run_command(build_cmd)
            
            if returncode != 0:
                self.log_error(f"Build failed for {element}: {stderr}")
    
    def _disable_stow_element(self, element: str):
        """Disables stow element"""
        stow_cmd = f"stow -D {shlex.quote(element)}"
        self.add_dry_run_op(
            Operation.DISABLE,
            f"Stow element: {element}",
            stow_cmd
        )
        
        if self.dry_run:
            return
        
        returncode, stdout, stderr = self.run_command(stow_cmd)
        if returncode != 0:
            self.log_warning(f"Failed to disable {element}: {stderr}")
    
    def uninstall_stow(self):
        """Disables all stow configurations"""
        self.log_info("Disabling Stow configurations")
        
        if 'WM' in self.config:
            for element in self.config['WM']:
                self._disable_stow_element(element)
        
        if 'PKGS' in self.config:
            for element in self.config['PKGS']:
                self._disable_stow_element(element)
    
    # ========== User Management ==========
    
    def manage_users(self):
        """Manages users based on declarative configuration"""
        if 'users' not in self.config:
            self.log_info("Users not defined in config")
            return
        
        distro_config = self.get_current_distro_config()
        if not distro_config:
            return
        
        users_config = distro_config.get('users', {})
        if not users_config:
            self.log_warning("User configuration not found for distribution")
            return
        
        self.log_info("Managing users")
        users = self.config.get('users', [])
        
        for user_config in users:
            if not isinstance(user_config, dict):
                continue
            
            user_name = user_config.get('name')
            if not user_name:
                continue
            
            enabled = user_config.get('enabled', True)
            
            if enabled:
                self._create_or_update_user(user_name, user_config, users_config)
            else:
                self._delete_user(user_name, user_config, users_config)
    
    def _check_user_exists(self, user_name: str, users_config: Dict[str, Any]) -> bool:
        """Checks if user exists"""
        exists_cmd = users_config.get('exists')
        if not exists_cmd:
            return False
        
        exists_cmd = exists_cmd.replace('%user%', user_name)
        returncode, stdout, stderr = self.run_command(exists_cmd)
        
        return returncode == 0 and stdout.strip() == "1"
    
    def _check_user_in_group(self, user_name: str, group: str, 
                           users_config: Dict[str, Any]) -> bool:
        """Checks if user is in group"""
        groups_config = users_config.get('groups', {})
        check_cmd = groups_config.get('check')
        
        if not check_cmd:
            return False
        
        check_cmd = check_cmd.replace('%user%', user_name).replace('%group%', group)
        returncode, stdout, stderr = self.run_command(check_cmd)
        
        return returncode == 0 and stdout.strip() == "1"
    
    def _get_user_groups(self, user_name: str, users_config: Dict[str, Any]) -> List[str]:
        """Gets user's group list"""
        groups_config = users_config.get('groups', {})
        list_cmd = groups_config.get('list')
        
        if not list_cmd:
            return []
        
        list_cmd = list_cmd.replace('%user%', user_name)
        returncode, stdout, stderr = self.run_command(list_cmd)
        
        if returncode == 0 and stdout:
            return [g.strip() for g in stdout.split()]
        
        return []
    
    def _create_or_update_user(self, user_name: str, user_config: Dict[str, Any],
                              users_config: Dict[str, Any]):
        """Creates or updates user"""
        user_exists = self._check_user_exists(user_name, users_config)
        
        if not user_exists:
            self._create_user(user_name, user_config, users_config)
        else:
            self._update_user(user_name, user_config, users_config)
    
    def _create_user(self, user_name: str, user_config: Dict[str, Any],
                    users_config: Dict[str, Any]):
        """Creates new user"""
        create_config = users_config.get('create', {})
        command = create_config.get('command')
        
        if not command:
            self.log_error(f"User creation command not defined")
            return
        
        shell = user_config.get('shell', '/bin/bash')
        command = command.replace('%user%', user_name).replace('%shell%', shell)
        
        self.add_dry_run_op(
            Operation.CREATE,
            f"User: {user_name}",
            command
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Creating user: {user_name}")
        returncode, stdout, stderr = self.run_command(command)
        
        if returncode != 0:
            self.log_error(f"Failed to create user {user_name}: {stderr}")
            return
        
        # Add user to groups
        groups = user_config.get('groups', [])
        for group in groups:
            self._add_user_to_group(user_name, group, users_config)
        
        # Unlock user if needed
        if not user_config.get('lock', False):
            self._unlock_user(user_name, users_config)
        else:
            self._lock_user(user_name, users_config)
    
    def _update_user(self, user_name: str, user_config: Dict[str, Any],
                    users_config: Dict[str, Any]):
        """Updates existing user"""
        # Update shell
        if 'shell' in user_config:
            self._modify_user_shell(user_name, user_config['shell'], users_config)
        
        # Update home directory
        if 'home' in user_config:
            self._modify_user_home(user_name, user_config['home'], users_config)
        
        # Manage locking
        should_be_locked = user_config.get('lock', False)
        current_groups = set(self._get_user_groups(user_name, users_config))
        
        # Check groups
        required_groups = set(user_config.get('groups', []))
        for group in required_groups:
            if group not in current_groups:
                self._add_user_to_group(user_name, group, users_config)
        
        # Remove extra groups (optional)
        # groups_to_remove = current_groups - required_groups
        # for group in groups_to_remove:
        #     if group not in ['users', user_name]:  # Don't remove default groups
        #         self._remove_user_from_group(user_name, group, users_config)
    
    def _delete_user(self, user_name: str, user_config: Dict[str, Any],
                    users_config: Dict[str, Any]):
        """Deletes user"""
        if not self._check_user_exists(user_name, users_config):
            return
        
        delete_config = users_config.get('delete', {})
        keep_home = user_config.get('keep_home', False)
        
        command = delete_config.get('keep_home' if keep_home else 'command')
        if not command:
            return
        
        command = command.replace('%user%', user_name)
        self.add_dry_run_op(
            Operation.DELETE,
            f"User: {user_name}",
            command
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Deleting user: {user_name}")
        returncode, stdout, stderr = self.run_command(command)
        
        if returncode != 0:
            self.log_error(f"Failed to delete user {user_name}: {stderr}")
    
    def _modify_user_shell(self, user_name: str, shell: str,
                          users_config: Dict[str, Any]):
        """Modifies user shell"""
        modify_config = users_config.get('modify', {})
        command = modify_config.get('shell')
        
        if not command:
            return
        
        command = command.replace('%user%', user_name).replace('%shell%', shell)
        self.add_dry_run_op(
            Operation.MODIFY,
            f"User {user_name} shell: {shell}",
            command
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Modifying user {user_name} shell: {shell}")
        returncode, stdout, stderr = self.run_command(command)
        
        if returncode != 0:
            self.log_error(f"Failed to modify user {user_name} shell: {stderr}")
    
    def _modify_user_home(self, user_name: str, home: str,
                         users_config: Dict[str, Any]):
        """Modifies user home directory"""
        modify_config = users_config.get('modify', {})
        command = modify_config.get('home')
        
        if not command:
            return
        
        command = command.replace('%user%', user_name).replace('%home%', home)
        self.add_dry_run_op(
            Operation.MODIFY,
            f"User {user_name} home directory: {home}",
            command
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Modifying user {user_name} home directory: {home}")
        returncode, stdout, stderr = self.run_command(command)
        
        if returncode != 0:
            self.log_error(f"Failed to modify user {user_name} home directory: {stderr}")
    
    def _add_user_to_group(self, user_name: str, group: str,
                          users_config: Dict[str, Any]):
        """Adds user to group"""
        if self._check_user_in_group(user_name, group, users_config):
            return
        
        groups_config = users_config.get('groups', {})
        command = groups_config.get('add')
        
        if not command:
            return
        
        command = command.replace('%user%', user_name).replace('%group%', group)
        self.add_dry_run_op(
            Operation.MODIFY,
            f"Adding user {user_name} to group: {group}",
            command
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Adding user {user_name} to group: {group}")
        returncode, stdout, stderr = self.run_command(command)
        
        if returncode != 0:
            self.log_error(f"Failed to add user {user_name} to group {group}: {stderr}")
    
    def _remove_user_from_group(self, user_name: str, group: str,
                               users_config: Dict[str, Any]):
        """Removes user from group"""
        if not self._check_user_in_group(user_name, group, users_config):
            return
        
        groups_config = users_config.get('groups', {})
        command = groups_config.get('remove')
        
        if not command:
            return
        
        command = command.replace('%user%', user_name).replace('%group%', group)
        self.add_dry_run_op(
            Operation.MODIFY,
            f"Removing user {user_name} from group: {group}",
            command
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Removing user {user_name} from group: {group}")
        returncode, stdout, stderr = self.run_command(command)
        
        if returncode != 0:
            self.log_error(f"Failed to remove user {user_name} from group {group}: {stderr}")
    
    def _lock_user(self, user_name: str, users_config: Dict[str, Any]):
        """Locks user"""
        modify_config = users_config.get('modify', {})
        command = modify_config.get('lock')
        
        if not command:
            return
        
        command = command.replace('%user%', user_name)
        self.add_dry_run_op(
            Operation.MODIFY,
            f"Locking user: {user_name}",
            command
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Locking user: {user_name}")
        returncode, stdout, stderr = self.run_command(command)
        
        if returncode != 0:
            self.log_error(f"Failed to lock user {user_name}: {stderr}")
    
    def _unlock_user(self, user_name: str, users_config: Dict[str, Any]):
        """Unlocks user"""
        modify_config = users_config.get('modify', {})
        command = modify_config.get('unlock')
        
        if not command:
            return
        
        command = command.replace('%user%', user_name)
        self.add_dry_run_op(
            Operation.MODIFY,
            f"Unlocking user: {user_name}",
            command
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"Unlocking user: {user_name}")
        returncode, stdout, stderr = self.run_command(command)
        
        if returncode != 0:
            self.log_error(f"Failed to unlock user {user_name}: {stderr}")
    
    # ========== System Settings Management ==========
    
    def manage_system(self):
        """Manages system settings"""
        if 'system' not in self.config:
            self.log_info("System settings not defined in config")
            return
        
        distro_config = self.get_current_distro_config()
        if not distro_config:
            return
        
        system_config = distro_config.get('system', {})
        if not system_config:
            self.log_warning("System configuration not found for distribution")
            return
        
        self.log_info("Managing system settings")
        config_system = self.config.get('system', {})
        
        for setting, value in config_system.items():
            if setting in system_config:
                self._manage_system_setting(setting, value, system_config[setting])
    
    def _manage_system_setting(self, setting: str, desired_value: str,
                              setting_config: Dict[str, Any]):
        """Manages individual system setting"""
        # Get current value
        get_cmd = setting_config.get('get')
        if not get_cmd:
            return
        
        returncode, current_value, stderr = self.run_command(get_cmd)
        if returncode != 0:
            self.log_error(f"Failed to get value for {setting}: {stderr}")
            return
        
        current_value = current_value.strip()
        
        # If value is already correct, do nothing
        if current_value == desired_value:
            return
        
        # Set new value
        set_cmd = setting_config.get('set')
        if not set_cmd:
            return
        
        set_cmd = set_cmd.replace('%value%', desired_value)
        self.add_dry_run_op(
            Operation.SET,
            f"{setting}: {current_value} → {desired_value}",
            set_cmd
        )
        
        if self.dry_run:
            return
        
        self.log_change(f"{setting}: {current_value} → {desired_value}")
        returncode, stdout, stderr = self.run_command(set_cmd)
        
        if returncode != 0:
            self.log_error(f"Failed to set {setting}: {stderr}")
    
    # ========== Main Execution Methods ==========
    
    def configure_all(self):
        """Executes full system configuration"""
        if not self.load_config():
            return
        
        if self.dry_run:
            print("\n" + "="*60)
            print("DRY RUN MODE")
            print("The following changes will be executed:")
            print("="*60 + "\n")
        
        self.manage_packages()
        self.manage_services()
        self.manage_system()
        self.manage_users()
        self.manage_extra_packages()
        self.manage_stow()
        
        if self.dry_run:
            self._show_dry_run_summary()
        else:
            print("\n" + "="*60)
            print("CONFIGURATION COMPLETED")
            print("="*60)
    
    def uninstall(self):
        """Disables configurations and stops services"""
        if not self.load_config():
            return
        
        if self.dry_run:
            print("\n" + "="*60)
            print("DRY RUN MODE")
            print("The following changes will be executed for uninstall:")
            print("="*60 + "\n")
        
        self.uninstall_stow()
        self.manage_services()  # This will disable and stop services
        
        if self.dry_run:
            self._show_dry_run_summary()
        else:
            print("\n" + "="*60)
            print("UNINSTALL COMPLETED")
            print("="*60)
    
    def remove_all(self):
        """Complete removal: packages, files, services, configurations"""
        if not self.load_config():
            return
        
        if self.dry_run:
            print("\n" + "="*60)
            print("DRY RUN MODE")
            print("The following changes will be executed for full removal:")
            print("="*60 + "\n")
        
        self.uninstall_stow()
        self.uninstall_extra_packages()
        self.manage_packages()
        self.manage_services()
        
        if self.dry_run:
            self._show_dry_run_summary()
        else:
            print("\n" + "="*60)
            print("FULL REMOVAL COMPLETED")
            print("="*60)
    
    def _show_dry_run_summary(self):
        """Shows dry-run operations summary"""
        if not self.dry_run_ops:
            print("No changes required.")
            return
        
        print("\n" + "="*60)
        print("CHANGES SUMMARY:")
        print("="*60)
        
        ops_by_type = {}
        for op in self.dry_run_ops:
            ops_by_type.setdefault(op.op, []).append(op)
        
        for op_type, ops in ops_by_type.items():
            print(f"\n{op_type.value} ({len(ops)}):")
            for op in ops:
                print(f"  • {op.description}")
                if op.command:
                    print(f"    Command: {op.command}")
        
        print("\n" + "="*60)
        print(f"Total operations: {len(self.dry_run_ops)}")
        print("="*60)


def show_help():
    """Shows help"""
    help_text = """Usage:
  goliaff                 - Full system configuration
  goliaff --dry-run       - Show what will be changed
  goliaff packages        - Manage only packages
  goliaff services        - Manage only services
  goliaff system          - Manage only system settings
  goliaff users           - Manage only users
  goliaff stow            - Manage only stow configurations
  goliaff uninstall       - Disable stow and services
  goliaff remove          - Full removal (stow, files, packages, services)
  goliaff help            - Show this help

Options:
  --dry-run, -d    Preview mode (don't execute commands)

Script expects config.json in current working directory.
"""
    print(help_text)


def main():
    if len(sys.argv) >= 2 and sys.argv[1] in ['help', '--help', '-h']:
        show_help()
        sys.exit(0)
    
    # Check for --dry-run flag
    dry_run = '--dry-run' in sys.argv or '-d' in sys.argv
    args = [arg for arg in sys.argv[1:] if arg not in ['--dry-run', '-d']]
    
    configurator = SystemConfigurator(dry_run=dry_run)
    
    if len(args) == 0:
        # Full configuration
        configurator.configure_all()
    elif args[0] == 'packages':
        if configurator.load_config():
            configurator.manage_packages()
            if dry_run:
                configurator._show_dry_run_summary()
    elif args[0] == 'services':
        if configurator.load_config():
            configurator.manage_services()
            if dry_run:
                configurator._show_dry_run_summary()
    elif args[0] == 'system':
        if configurator.load_config():
            configurator.manage_system()
            if dry_run:
                configurator._show_dry_run_summary()
    elif args[0] == 'users':
        if configurator.load_config():
            configurator.manage_users()
            if dry_run:
                configurator._show_dry_run_summary()
    elif args[0] == 'stow':
        if configurator.load_config():
            configurator.manage_stow()
            if dry_run:
                configurator._show_dry_run_summary()
    elif args[0] == 'uninstall':
        configurator.uninstall()
    elif args[0] == 'remove':
        configurator.remove_all()
    else:
        print(f"Unknown command: {args[0]}")
        show_help()
        sys.exit(1)


if __name__ == '__main__':
    main()
